[
  {
    "path": "posts/tutorial-dados-comerciais-brasileiros-parte-i/",
    "title": "Tutorial - Dados Comerciais Brasileiros, Parte I",
    "description": "Leitura e transformação da base de dados do Ministério da Economia.",
    "author": [
      {
        "name": "Fernando Bastos",
        "url": {}
      }
    ],
    "date": "2021-01-01",
    "categories": [],
    "contents": "\n\nContents\nObjetivo\nLeitura de dados\nTransformação dos dados\nPassagem do NCM ao SH4\nAdicionando novas colunas à tabela\nResumindo os Dados\n\n\nPróximas etapas\n\nObjetivo\nO objetivo desse tutorial é, a partir dos dados disponibilizados pelo Ministério da Economia, analisar os principais fatores básicos do comércio exterior brasileiro - principais parceiros comerciais, principais produtos comercializados, bem como relações simples entre parceiros comerciais e produtos comercializados. O tutorial foi feito em R e não exige nada além do que conhecimento básico na linguagem. Pra falar a verdade, esse tutorial pode ser visto como uma espécie de introdução a alguns dos conceitos mais importantes do tidyverse, conjunto de pacotes nada menos que fenomenais para qualquer um que trabalha com ciência de dados.\nA primeira parte do projeto apresenta o momento da limpeza dos dados. A segunda parte trabalhará na formulação dos gráficos com o pacote ggplot2. A terceira apresentará conceitos um pouco mais avançados envolvendo transformação e visualização. Na quarta parte, criaremos um relatório com os gráficos construídos anteriormente utilizando o R Markdown. Na quinta parte, utilizaremos o pacote Shiny para criar um site simples que servirá como repositório desses dados na internet. Ao fim e ao cabo, teremos à nossa disposição uma aplicação que cria relatórios de comércio automatizados para países parceiros do Brasil.\nLeitura de dados\nOs dados de Comércio Exterior que utilizamos estão disponíveis no site do Ministério da Economia. Para ler os arquivos, contudo, é preciso antes identificar os arquivos com os dados de exportações e importações. Para isso, usaremos o pacote “fs” com o auxílio do pacote “here”. Após fazer o download dos arquivos com os últimos 10 anos de comércio (ou quantos anos você quiser), podemos passar o seguinte código, criando dois vetores com os nomes dos respectivos arquivos. A partir deles, poderemos ler os vários arquivos de uma vez só.\n\n\nexp_files <- fs::dir_ls(path = here(\"input\", \"mdic\", \"exp\"), glob = \"*.csv\")\nimp_files <- fs::dir_ls(path = here(\"input\", \"mdic\", \"imp\"), glob = \"*.csv\")\n\n\n\nAgora que temos os nomes dos arquivos, podemos iniciar a leitura dos dados. Essa base de dados é grande, portanto deve haver outras maneiras mais inteligentes de lê-lo. Particularmente, tive dificuldades de incorporar esses dados numa base de dados SQL (pura ignorância deste que vos escreve, um dia aprenderei a usar o SQL de maneira digna). A maneira mais clássica e simples de se ler esses dados costuma conjugar as funções purr::map_df com a função read_csv2. Contudo, por se tratar de uma base grande, percebi que o pacote vroom atendia melhor aos meus interesses. Por isso, em vez de apostar na abordagem clássica, utilizarei o pacote vroom. Se você tem uma base de dados grande que caiba em sua memória, não vejo motivos para não usar o vroom.\nO pacote vroom é surrealmente rápido. Chega a ser inacreditável. Ele lê arquivos com mais de 2 gigas com a tranquilidade de um senhor aposentado escutando jazz. Eu não sei como isso é possível, mas é real. No código abaixo, lemos primeiro cada um dos arquivos de exportação e importação.\n\n\nexp <- vroom::vroom(exp_files, col_select = c(CO_ANO, CO_MES, CO_NCM, CO_PAIS, VL_FOB), \n                    col_types = c(CO_ANO = \"i\", CO_MES = \"i\", CO_NCM = \"c\", CO_PAIS = \"c\", VL_FOB = \"i\")) %>%\n  mutate(trade_flow = \"exp\")\nimp <- vroom::vroom(imp_files, col_select = c(CO_ANO, CO_MES, CO_NCM, CO_PAIS, VL_FOB), \n                    col_types = c(CO_ANO = \"i\", CO_MES = \"i\", CO_NCM = \"c\", CO_PAIS = \"c\", VL_FOB = \"i\")) %>%\n  mutate(trade_flow = \"imp\")\n\n\n\nAgora que temos cada um dos arquivos de exportações e importações, o trabalho é juntá-los. Isso não é difícil, basta unir as linhas. Após unir as linhas, vamos remover as variáveis antigas porque elas não são mais necessárias (e tentar salvar alguma memória RAM no processo).\n\n\nexp_imp <- bind_rows(exp, imp)\n\nrm(exp, imp)\n\n\n\nTransformação dos dados\nPassagem do NCM ao SH4\nAdicionando novas colunas à tabela\nCom os dados consolidados numa única variável, precisamos dar início à integração das informações com as referências oferecidas pelo próprio Ministério da Economia. Temos os códigos NCM (Nomenclatura Comum do MERCOSUL) dos produtos comercializados, mas ainda nos faltam os nomes dos produtos, os nomes dos países e outras informações relevantes. A primeira integração que faremos será a partir do arquivo “NCM.csv”, também baixado no mesmo site em que o Ministério da Economia ofereceu todos os dados. Com isso, teremos a correlação possível entre os códigos NCM e SH6, além dos códigos de ISIC e Fator Agregado.\n\n\nncm <- read_csv2(here(\"input\", \"mdic\", \"dicionários\", \"NCM.csv\")) %>% \n  select(CO_NCM, CO_SH6, CO_FAT_AGREG, CO_ISIC_CLASSE)\n\nexp_imp <- exp_imp %>%\n  left_join(ncm)\n\nexp_imp\n\n\n# A tibble: 32,166,474 x 9\n   CO_ANO CO_MES CO_NCM CO_PAIS VL_FOB trade_flow CO_SH6 CO_FAT_AGREG\n    <int>  <int> <chr>  <chr>    <int> <chr>      <chr>  <chr>       \n 1   2010      4 85011… 063        886 exp        850110 03          \n 2   2010      7 99997… 158        258 exp        999971 04          \n 3   2010      1 73079… 158        116 exp        730799 03          \n 4   2010     10 84813… 337      18894 exp        848130 03          \n 5   2010      1 73182… 158         63 exp        731822 03          \n 6   2010      1 32074… 196      57365 exp        320740 03          \n 7   2010      1 40114… 676      26789 exp        401140 03          \n 8   2010      4 84339… 097      29820 exp        843390 03          \n 9   2010      7 33059… 169     480407 exp        330590 03          \n10   2010      1 84213… 391         88 exp        842131 03          \n# … with 32,166,464 more rows, and 1 more variable:\n#   CO_ISIC_CLASSE <chr>\n\nOs dados iniciais, baseados em NCM, não são tão úteis aos nossos propósitos porque são tão dispersos que dificultam a interpretação das informações. Queremos trabalhar com dados um pouco mais agregados, utilizando os códigos do Sistema Harmonizado (SH) com 4 dígitos. Com isso, acreditamos que poderemos ter uma boa avaliação do comércio brasileiro. Para realizar esse passo, contudo, ainda precisamos agregar outros dados a partir do arquivo “NCM_SH.csv”.\nA partir da agregação anterior, tivemos acesso à coluna CO_SH6. Essa coluna servirá de referência para descobrirmos o código em SH4 de cada um dos produtos.\n\n\nncm_sh <- read_csv2(here(\"input\", \"mdic\", \"dicionários\", \"NCM_SH.csv\"), locale = locale(encoding = \"ISO-8859-1\")) %>% \n  select(CO_SH6, CO_SH4, NO_SH4_POR)\n\nexp_imp <- exp_imp %>%\n  left_join(ncm_sh)\n\nexp_imp\n\n\n# A tibble: 32,166,474 x 11\n   CO_ANO CO_MES CO_NCM CO_PAIS VL_FOB trade_flow CO_SH6 CO_FAT_AGREG\n    <int>  <int> <chr>  <chr>    <int> <chr>      <chr>  <chr>       \n 1   2010      4 85011… 063        886 exp        850110 03          \n 2   2010      7 99997… 158        258 exp        999971 04          \n 3   2010      1 73079… 158        116 exp        730799 03          \n 4   2010     10 84813… 337      18894 exp        848130 03          \n 5   2010      1 73182… 158         63 exp        731822 03          \n 6   2010      1 32074… 196      57365 exp        320740 03          \n 7   2010      1 40114… 676      26789 exp        401140 03          \n 8   2010      4 84339… 097      29820 exp        843390 03          \n 9   2010      7 33059… 169     480407 exp        330590 03          \n10   2010      1 84213… 391         88 exp        842131 03          \n# … with 32,166,464 more rows, and 3 more variables:\n#   CO_ISIC_CLASSE <chr>, CO_SH4 <chr>, NO_SH4_POR <chr>\n\nPor fim, precisamos apenas de dois joins: aquele no qual pegamos os nomes dos países e aquele no qual pegamos o nome dos produtos em SH4. Farei os dois joins de uma só vez.\nPor fim, vamos tirar proveito do fato que a Coluna “CO_FAT_AGREG”, com o código do Fator Agregado de cada um dos produtos, tem apenas seis categorias diferentes. Poderíamos fazer mais um join, mas precisaríamos trocar os nomes (eles estão todos em Caixa Alta, péssimos para a leitura). Para evitar trabalhar em dobro, vamos simplesmente trocar o nome das colunas, usando a função “case_when”. A função case_when é muito útil para, a partir de um determinado input lógico, realizar uma tarefa. A função se lê da seguinte maneira:\ncase_when(str_detect(CO_FAT_AGREG, “Número”)\n“Caso se detecte o número tal na coluna CO_FAT_AGREG”\n\n~ “Nome”\n“Então mude o nome para”Nome\".\n\nO case_when é uma função extremamente útil para aterar valores de linhas.\nSe deu certo até aqui, pode correr pro abraço. Levante as mãos pros céus porque esse projeto cabe em sua memória RAM.\nVamos ao próximo passo. Resumir os dados.\n\n\npais <- read_csv2(here(\"input\", \"mdic\", \"dicionários\", \"PAIS.csv\"), locale = locale(encoding = \"ISO-8859-1\")) %>%\n  select(CO_PAIS, NO_PAIS)\nncm_isic <- read_csv2(here(\"input\", \"mdic\", \"dicionários\", \"NCM_ISIC.csv\"), locale = locale(encoding = \"ISO-8859-1\")) %>%\n  select(CO_ISIC_CLASSE, NO_ISIC_SECAO)\n\nexp_imp <- exp_imp %>% \n  left_join(pais) %>%\n  left_join(ncm_isic) %>%\n  mutate(CO_FAT_AGREG = case_when(str_detect(CO_FAT_AGREG, \"01\") ~ \"Produtos Básicos\",\n                                    str_detect(CO_FAT_AGREG, \"02\") ~ \"Produtos Semimanufaturados\",\n                                    str_detect(CO_FAT_AGREG, \"03\") ~ \"Produtos Manufaturados\",\n                                    str_detect(CO_FAT_AGREG, \"04\") ~ \"Transações Especiais\",\n                                    str_detect(CO_FAT_AGREG, \"05\") ~ \"Consumo de Bordo\",\n                                    str_detect(CO_FAT_AGREG, \"06\") ~ \"Reexportação\",\n                                    TRUE ~ \"Não identificado\")) %>% \n  rename(fator_agregado = CO_FAT_AGREG)\n  \nexp_imp\n\n\n# A tibble: 32,166,474 x 13\n   CO_ANO CO_MES CO_NCM CO_PAIS VL_FOB trade_flow CO_SH6\n    <int>  <int> <chr>  <chr>    <int> <chr>      <chr> \n 1   2010      4 85011… 063        886 exp        850110\n 2   2010      7 99997… 158        258 exp        999971\n 3   2010      1 73079… 158        116 exp        730799\n 4   2010     10 84813… 337      18894 exp        848130\n 5   2010      1 73182… 158         63 exp        731822\n 6   2010      1 32074… 196      57365 exp        320740\n 7   2010      1 40114… 676      26789 exp        401140\n 8   2010      4 84339… 097      29820 exp        843390\n 9   2010      7 33059… 169     480407 exp        330590\n10   2010      1 84213… 391         88 exp        842131\n# … with 32,166,464 more rows, and 6 more variables:\n#   fator_agregado <chr>, CO_ISIC_CLASSE <chr>, CO_SH4 <chr>,\n#   NO_SH4_POR <chr>, NO_PAIS <chr>, NO_ISIC_SECAO <chr>\n\nResumindo os Dados\nA variável exp_imp é muito grande (ultrapassa dois Gigas). O objetivo agora é agregar os dados em torno do SH4 e não mais em NCM. Com isso, teremos uma base de dados bem mais compacta para trabalhar. Não queremos perder dados de Ano, Mês, Países e de direção do comércio, por isso vamos acrescentar essas variáveis no agrupamento. Além disso, não queremos perder os dados relacionados ao ISIC e ao Fator Agregado, por isso também vamos adicioná-los.\nAlém disso, vou descumprir um princípio básico do tratamento de dados por aqui, mas é por uma boa causa. No nosso relatório, iremos trabalhar com duas análises distintas: por um lado, queremos os dados de comércio divididos por ano; do outro lado, queremos a análise do ano atual, sempre incompleto da perspectiva de meses. No primeiro caso, os meses são irrelevantes - trabalhamos apenas com anos. No segundo caso, nos importa tanto os anos quanto os meses.\nPor uma questão de praticidade, dividirei em duas bases de dados: uma na qual o mês é relevante e outra na qual queremos apenas os anos.\nA base exp_imp_mes tomará por referência o mês atual e comparará o ano atual com os anos anteriores até o limite do mês atual. Se estamos no mês de março, veremos a comparação dos últimos 10 anos, com informações disponíveis até o mês de março.\nA base exp_imp tomará por referência o último ano completo anterior. Se estamos no ano de 2021, nossa análise se limitará até o ano de 2020.\nPara identificar o último mês, precisamos encontrar de maneira automatizada o código do último mês no último ano da base de dados. Para isso, foram realizadas duas filtragens: primeiro filtramos apenas o último ano com a função max(CO_ANO). Depois, filtramos a coluna dos meses com a mesma função max(CO_MES). Em seguida, foram utilizadas duas funções muito úteis que costumam ser usadas de maneira conjunta: distinct() (que nos dá apenas resultados únicos) e pull() (que nos retorna o resultado como um vetor). Com essas linhas de código, não precisomos mudar manualmente o mês de referência toda vez que a base de dados é atualizadas.\n\n\nultimo_mes <- exp_imp %>%\n  filter(CO_ANO == max(CO_ANO)) %>%\n  select(CO_MES) %>%  \n  filter(CO_MES == max(CO_MES)) %>%\n  distinct() %>%\n  pull(CO_MES)\n\n\n\nAgora que temos o mês de referência, podemos criar uma base de dados a partir da qual é realizada uma filtragem para garantir que nenhum mês acima do mês de referência seja contabilizado. Além disso, eu tento tirar da base de dados todos os resultados nulos da coluna VL_FOB (a coluna que mede o valor de cada transação). Com isso, está praticamente tudo pronto para fechar nosso arquivo final de trabalho. Nossa primeira etapa está quase concluída.\nAs variáveis que quero trabalhar são: Ano, País, Fluxo de Comércio, Mercadorias em SH4, Fator ISIC e Fator Agregado. Se eu agrupar esses dados e realizar a soma da coluna VL_FOB eu terei todas as informações que quero tomando por referência a SH4. (Se eu quisesse tomar por base outras referências, digamos, como SH6 ou SH2, eu também poderia, bastando apenas selecionar as colunas NO_SH2 ou NO_SH6 no lugar da coluna do SH4). Com isso, as duas bases de dados que temos são as seguintes.\n\n\nexp_imp_mes <- exp_imp %>%\n  filter(!is.na(VL_FOB)) %>% \n  filter(CO_MES <= ultimo_mes) %>% \n  group_by(CO_ANO, NO_PAIS, trade_flow, NO_SH4_POR, NO_ISIC_SECAO, fator_agregado) %>%\n  summarise(value = sum(VL_FOB)) %>%\n  ungroup()\n\nexp_imp <- exp_imp %>%\n  # group_by(CO_ANO, CO_PAIS, trade_flow, CO_SH4) %>%\n  filter(!is.na(VL_FOB)) %>% \n  group_by(CO_ANO, NO_PAIS, trade_flow, NO_SH4_POR, NO_ISIC_SECAO, fator_agregado) %>%\n  summarise(value = sum(VL_FOB)) %>%\n  ungroup()\n\n\n\nA vantagem de realizar essa agregação em SH4 ou em SH2 é que, assim, a base de dados fica muito mais leve. Das próximas vezes, enquanto os dados não forem atualizados, podemos usar apenas os dados já transformados. Para isso, precisamos apenas consolidar os dados em um novo arquivo csv. Eu gosto da função vroom_write para fazer isso.\n\n\nvroom::vroom_write(exp_imp_mes, here(\"input\", \"mdic\", \"exp_imp_mes.csv\"))\nvroom::vroom_write(exp_imp, here(\"input\", \"mdic\", \"exp_imp.csv\"))\n\n\n\nPróximas etapas\nO objetivo desse programa é construir, automaticamente, relatórios do comércio bilateral do Brasil com países disponíveis na base de dados do Ministério da Economia. Assim, esta primeira etapa serviu apenas para construir a base de dados que servirá como referência para tal projeto.\nNas próximas etapas, identificaremos as primeiras informações básicas do relatório. Tentaremos descobrir os principais parceiros comerciais do Brasil, os principais produtos comercializados e as interações entre as duas dimensões: por um lado os parceiros, por outro os produtos. Mais tarde, tentaremos construir um esqueleto para que a análise de produtos e países seja feita de maneira automatizada a partir da base de dados do Ministério da Economia.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-01-01T21:01:25-03:00",
    "input_file": {}
  },
  {
    "path": "posts/tutorial-dados-comerciais-brasileiros-parte-ii/",
    "title": "Tutorial - Dados Comerciais Brasileiros, Parte II",
    "description": "ggplot2 - fluxo de comércio e visualisação de dados",
    "author": [
      {
        "name": "Fernando Bastos",
        "url": {}
      }
    ],
    "date": "2021-01-01",
    "categories": [],
    "contents": "\n\nContents\nObjetivo\nPreparando os dados\nFiltrando os dados\nDo formato long ao formato wide\nSomando colunas\nDe volta ao tidy\n\nUsando o ggplot\nFacetando\nIdentificando problemas\nReordenando com factors\nTornando gráficos legíveis com labels\nTemas\nMinimalismo tá na moda mas nem por isso é ruim\nJamais deixar de dar os créditos\nJuntando tudo\n\nPróximos passos\n\nObjetivo\nO objetivo desse tutorial é criar nosso primeiro gráfico com as informações coletadas no tutorial anterior. Pretendemos tomar as primeiras informações, das mais primárias, a partir do arquivo csv que geramos: pretendemos realizar um gráfico de fluxo de comércio, envolvendo exportações, importações, saldo e corrente de comércio. Trata-se de uma apresentação básica da relação bilateral comercial de qualquer país. A partir daqui, poderemos desenvolver melhor conceitos relacionados à lógica do próprio tidyverse (o formato tidy de tabelas) e apresentaremos algumas das muitas possibilidades disponíveis no lendário pacote ggplot2.\nPreparando os dados\nNo último tutorial preparamos os dados necessários para começar analisar o comércio internacional brasileiro. Eu sei que eu tinha prometido que a preparação dos dados tinha acabado - mas na verdade eu menti. A depender da informação que queremos apresentar, outras transformações devem ser realizadas. Antes, contudo, precisamos ler os dados. Usaremos a função vroom, do pacote de mesmo nome, porque ela é simplesmente incrível. A vida é muito curta para ler dados lentamente. O arquivo lido é o mesmo do tutorial anterior.\n\n\nexp_imp <- vroom::vroom(here(\"input\", \"mdic\", \"exp_imp.csv\"))\nexp_imp_mes <- vroom::vroom(here(\"input\", \"mdic\", \"exp_imp_mes.csv\")) \n\n\n\nA primeira coisa que queremos é analisar o comércio como um todo do Brasil com um determinado país. Vamos supor, para fins deste tutorial, que queremos apenas os dados com a China. (Mais tarde tentaremos generalizar os resultados. Inicialmente, contudo, tentaremos fazer um trabalho de visualização de dados com um único país)\nFiltrando os dados\nNo nosso objetivo, o primeiro passo é realizar um filtro na base de dados para selecionarmos apenas as linhas relacionadas à China. Para isso, passamos a função do dplyr “filter” com a expressão “NO_PAIS == filtro”. Como se pode ver, caso queiramos qualquer outro país a ser selecionado, basta alterar a variável “filtro”. Em seguida, agruparemos os dados por ano e por direção de comércio e somaremos o resultado. Como se vê, o resultado são três colunas: uma para ano, outra para fluxo de comércio e outra para o valor exportado ou importado em cada ano.\n\n\nfiltro <- \"China\"\n\ndf <- exp_imp %>%\n  filter(NO_PAIS == filtro) %>%\n  # filter(is.na(value)) \n  group_by(CO_ANO, trade_flow) %>%\n  summarise(value = sum(value))\n\ndf\n\n\n# A tibble: 22 x 3\n# Groups:   CO_ANO [11]\n   CO_ANO trade_flow       value\n    <dbl> <chr>            <dbl>\n 1   2010 exp        30747553704\n 2   2010 imp        25591460070\n 3   2011 exp        44304607898\n 4   2011 imp        32786471278\n 5   2012 exp        41225811420\n 6   2012 imp        34244854596\n 7   2013 exp        46023192076\n 8   2013 imp        37326092484\n 9   2014 exp        40611876675\n10   2014 imp        37338629829\n# … with 12 more rows\n\nDo formato long ao formato wide\nO resultado acima é bastante satisfatório mas não nos dá algumas informações bastante importantes: qual o saldo comercial (exportações menos importações) do Brasil com a China e qual a corrente de comércio (exportações mais importações) entre os dois países? Para realizar essa operação, o formato “long”, ou “tidy”1 não é dos melhores. O ideal é somar uma coluna à outra, não é fácil propriamente somar linhas específicas na atual configuração. Para isso, usaremos duas funções bastante importantes: a pivot_wider e a pivot_longer.\nComo se pode observar abaixo, queremos que as linhas da variável “trade_flow” se transformem em nomes de colunas. No caso, queremos que a coluna de “exportações” e a coluna de “importações” sejam colunas independentes com valores definidos pela coluna “value”. Se cada uma delas for uma coluna distinta, podemos somá-las, subtraí-las, multiplicá-las… vai do seu interesse. No nosso caso, estamos satisfeitos com operações básicas.\n\n\ndf <- df %>% \n  pivot_wider(names_from = trade_flow, values_from = value) \n\ndf\n\n\n# A tibble: 11 x 3\n# Groups:   CO_ANO [11]\n   CO_ANO         exp         imp\n    <dbl>       <dbl>       <dbl>\n 1   2010 30747553704 25591460070\n 2   2011 44304607898 32786471278\n 3   2012 41225811420 34244854596\n 4   2013 46023192076 37326092484\n 5   2014 40611876675 37338629829\n 6   2015 35549534578 30714594211\n 7   2016 35133314867 23357532623\n 8   2017 47488449966 27321495733\n 9   2018 63929548814 34730027163\n10   2019 63357520588 35270816762\n11   2020 63191994262 30819510621\n\nSomando colunas\nAgora que temos as duas colunas que queremos, precisamos criar as novas duas colunas que buscamos. Para isso, criamos colunas com a função “mutate”, também do dplyr. Além disso, vamos alterar o nome das colunas com a função “rename” para que nosso gráfico fique mais bonito lá na frente.\n\n\ndf <- df %>% \n  mutate(Corrente = exp + imp,\n         Saldo = exp - imp) %>%\n  rename(Exportações = exp,\n         Importações = imp)\n\ndf\n\n\n# A tibble: 11 x 5\n# Groups:   CO_ANO [11]\n   CO_ANO Exportações Importações    Corrente       Saldo\n    <dbl>       <dbl>       <dbl>       <dbl>       <dbl>\n 1   2010 30747553704 25591460070 56339013774  5156093634\n 2   2011 44304607898 32786471278 77091079176 11518136620\n 3   2012 41225811420 34244854596 75470666016  6980956824\n 4   2013 46023192076 37326092484 83349284560  8697099592\n 5   2014 40611876675 37338629829 77950506504  3273246846\n 6   2015 35549534578 30714594211 66264128789  4834940367\n 7   2016 35133314867 23357532623 58490847490 11775782244\n 8   2017 47488449966 27321495733 74809945699 20166954233\n 9   2018 63929548814 34730027163 98659575977 29199521651\n10   2019 63357520588 35270816762 98628337350 28086703826\n11   2020 63191994262 30819510621 94011504883 32372483641\n\nDe volta ao tidy\nAgora temos todas as informações que queremos para fazer um gráfico com o ggplot, pacote do tidyverse absolutamente matador em matéria de visualização de dados. Antes, contudo, precisamos retornar nosso dataframe ao formato tidy. Se, antes, utilizamos a função “pivot_wider”, agora usaremos a função inversa, “pivot_longer”. Selecionaremos as colunas que queremos que se transformem em linhas (no caso, todas as colunas entre Exportações e Saldo, utilizando o operador “:”), e logo em seguida selecionamos o que devemos fazer com os “valores” de cada uma dessas colunas (no caso, eles voltaram à coluna “value”).\n\n\ndf <- df %>% \n  pivot_longer(cols = Exportações:Saldo, names_to = \"trade_flow\", values_to = \"value\")\n\ndf\n\n\n# A tibble: 44 x 3\n# Groups:   CO_ANO [11]\n   CO_ANO trade_flow        value\n    <dbl> <chr>             <dbl>\n 1   2010 Exportações 30747553704\n 2   2010 Importações 25591460070\n 3   2010 Corrente    56339013774\n 4   2010 Saldo        5156093634\n 5   2011 Exportações 44304607898\n 6   2011 Importações 32786471278\n 7   2011 Corrente    77091079176\n 8   2011 Saldo       11518136620\n 9   2012 Exportações 41225811420\n10   2012 Importações 34244854596\n# … with 34 more rows\n\nUsando o ggplot\nPronto. Finalmente podemos começar a usar o ggplot. Na sintaxe do ggplot, devemos primeiro criar o quadro em branco a partir do qual se deve construir o gráfico chamando a função “ggplot()”. Em seguida, chamamos a função geom_qualquercoisa para definir qual figura geométrica queremos que o gráfico utilize. É uma estrutura bastante simples que está representada abaixo. No caso, selecionamos o gráfico de colunas (geom_col). Dentro do geom_col, a função aes() serve para selecionar quais as variáveis que devem ser apresentadas. O eixo X, no gráfico abaixo, está representando os anos (coluna CO_ANO) e o eixo Y representa as quantidades (coluna value). Por fim, a variável “fill”, dentro da função “aes()” cumpre a função de pintar de cores diferentes cada tipo de fluxo de comércio (se exportações, importações, corrente ou saldo).\n\n\ndf <- df %>% \n  ggplot() +\n  geom_col(aes(CO_ANO, value, fill = trade_flow))\n\ndf\n\n\n\n\nFacetando\nCaso quiséssemos, poderíamos terminar nosso trabalho nesse momento. Mas o gráfico está, convenhamos, um tanto quanto feio e, pior ainda, ele não passa informações de maneira clara. Podemos discernir tendências muito evidentes, mas relações internas ao movimento de exportações ou importações não estão fáceis de serem visualizadas. Queremos ter a capacidade de verificar as tendências de cada um dos quatro fluxos de comércio (exp, imp, saldo, corrente) de maneira independente. Para a nossa sorte, o ggplot torna isso muito fácil. Vamos utilizar, no caso, a função facet_wrap() para dividir a visualização de cada uma das variáveis.\n\n\ndf +\n  facet_wrap(~ trade_flow)\n\n\n\n\nIdentificando problemas\nAgora está muito melhor, apesar de ainda termos alguns problemas. De todo modo, o gráfico já está numa posição muito mais próxima do nosso objetivo final. Os problemas identificados são:\na ordem do gráfico não está legal. Seria melhor se pudéssemos incluir exportações ao lado das importações, assim como posicionar lado a lado corrente e saldo.\nAlém disso, o eixo Y está usando notação científica, difícil de entender, e o eixo X está dividindo os números inteiros dos anos.\nHá, ainda, uma legenda ao lado completamente desnecessária porque o nome de cada gráfico já nos dá a informação que queremos.\nPra piorar, essas cores são horríveis.\nVamos tentar solucionar cada um dos problemas, um a um.\nEm geral, quando se está operando com variáveis categóricas (isto é, variáveis que não são quantitativas) no R, e queremos ordená-las de alguma maneira, devemos utilizar “fatores”.\nReordenando com factors\nPara transformar uma determinada variável em fator, passamos a função “factor” e selecionamos os níveis de ordenamento, no caso “levels”. Eu quero que, em primeiro lugar, apareça o gráfico de “Exportações”, em segundo lugar o gráfico de “Importações” e assim vai. Além disso, eu faço questão que o eixo X apareça tanto nos gráficos da parte de baixo, quanto da parte de cima. Para realizar essa operação, eu adiciono o parâmetro “scales” com a opção “free_x” que faz justamente isso: torna o eixo X livre e independente da parte de baixo. Vamos ao resultado.\n\n\ndf <- df +\n  facet_wrap(~ factor(trade_flow, levels = c(\"Exportações\", \"Importações\", \"Corrente\", \"Saldo\")),\n             scales = \"free_x\")\n\ndf\n\n\n\n\nTornando gráficos legíveis com labels\nO primeiro passo foi resolvido. Os gráficos estão em ordem. O segundo passo deve ser, então, alterar o formato da escala dos eixos X e Y. Em primeiro lugar, alterar a notação científica do eixo Y que está simplesmente ilegível. Em segundo, não deixar que o ggplot apresente o eixo X em formato não inteiro porque isso não faz sentido. Para isso, utilizaremos duas funções: scale_x_continuous e scale_y_continuous porque nossas duas variáveis são contínuas. No eixo y, utilizaremos a função “label_number_si” para que possamos ler números grandes em formato intuitivo. Além disso, passaremos a função pretty_breaks no parametro “breaks” para que as quebras entre as observações seja feita de maneira bonita e inteligente. Imagina se tivéssemos que selecionar à mão a quantidade de espaços em branco, o número de observações de cada um dos gráficos? Trabalho danado. Muita preguiça. Por sorte, essas duas funções do pacote ‘scales’ existem para nos salvar.\n\n\ndf <- df +\n  scale_y_continuous(labels = label_number_si(accuracy = 0.01), breaks = pretty_breaks()) +\n  scale_x_continuous(breaks = scales::pretty_breaks())\n\ndf\n\n\n\n\nTemas\nMuito melhor, não é mesmo? Ainda temos pequenos problemas: a legenda inútil à direita, o nome dos eixos X e Y e, enfim, essas cores que, convenhamos, estão horríveis.\nO primeiro passo é usar outra função, dessa vez do pacote “ggthemes” que serve para selecionar temas pré-estabelecidos de cores e tudo mais. No meu caso, eu gosto do scale_fill_tableau(). Você pode escolher qualquer um que quiser.\n\n\ndf <- df +\n  scale_fill_tableau()\n\ndf\n\n\n\n\nMinimalismo tá na moda mas nem por isso é ruim\nMuito mais bonito, fala sério. Para retirar as duas legendas é mais fácil ainda. Passamos a função theme, também do ggplot, com os seguintes parâmetros abaixo.\n\n\ndf <- df +\n  theme(legend.position = \"none\", axis.title.x = element_blank(),\n          axis.title.y = element_blank())\n\ndf\n\n\n\n\nJamais deixar de dar os créditos\nPor fim, o detalhe final: podemos colocar um título no gráfico e uma legenda abaixo, referenciando a fonte dos dados.\n\n\ndf <- df +\n  labs(title = glue(\"Brasil-{filtro}, Corrente de Comércio\"),\n       caption = \"Fonte: Ministério da Economia\")\ndf\n\n\n\n\nJuntando tudo\nÉ o gráfico mais lindo do mundo? Certamente não. Mas funciona. Se quisermos juntar todos os passos em um só, o código seria o seguinte:\n\n\nexp_imp %>%\n  filter(NO_PAIS == filtro) %>%\n  group_by(CO_ANO, trade_flow) %>%\n  summarise(value = sum(value)) %>%\n  pivot_wider(names_from = trade_flow, values_from = value) %>%\n  mutate(Corrente = exp + imp,\n         Saldo = exp - imp) %>%\n  rename(Exportações = exp,\n         Importações = imp) %>%\n  pivot_longer(cols = Exportações:Saldo, names_to = \"trade_flow\", values_to = \"value\") %>% \n  ggplot() +\n  geom_col(aes(CO_ANO, value, fill = trade_flow)) +\n  facet_wrap(~ factor(trade_flow, levels = c(\"Exportações\", \"Importações\", \"Corrente\", \"Saldo\")),\n             scales = \"free_x\") +\n  scale_y_continuous(labels = label_number_si(accuracy = 0.01), breaks = pretty_breaks()) +\n  scale_x_continuous(breaks = scales::pretty_breaks()) +\n  scale_fill_tableau() +\n  theme(legend.position = \"none\", axis.title.x = element_blank(),\n        axis.title.y = element_blank()) +\n  labs(title = glue(\"Brasil-{filtro}, Corrente de Comércio\"),\n       caption = \"Fonte: Ministério da Economia\")\n\n\n\n\nPróximos passos\nAgora que temos nosso primeiro gráfico, o céu é o limite. A partir daqui, tentaremos desenvolver melhor as informações necessárias para um bom relatório com um apanhado geral da relação comercial do Brasil com seus parceiros. Depois disso, tentaremos generalizar o procedimento para que ele seja viável, de maneira automática, para todos os outros parceiros comerciais. Mas até lá tem um bom caminho pela frente. Nos vemos nos próximos capítulos.\n\nO formato tidy é um dos conceitos mais importantes do tidyverse. Depois que eu compreendi a lógica básica do conceito, pude perceber a força e a riqueza da construção. Para transformar uma determinada tabela em tidy, basta seguir a seguinte determinação: cada coluna equivale a uma variável, cada linha uma observaçãoo relacionada à variável. Curto e simples. Acho belo. No entanto, como podemos ver no caso em questão, nem sempre o formato tidy é o mais adequado para se trabalhar↩︎\n",
    "preview": "posts/tutorial-dados-comerciais-brasileiros-parte-ii/distill-preview.png",
    "last_modified": "2021-01-01T21:52:29-03:00",
    "input_file": {}
  }
]
